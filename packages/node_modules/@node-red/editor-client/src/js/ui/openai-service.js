/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.openAIService = (function() {
    // Configuration object
    const config = {
        apiKey: "",
        model: "claude-3-5-sonnet-20240620",
        temperature: 0.0
    };

    // Function to load configuration from Node-RED settings
    function loadConfig() {
        if (RED.settings?.openai) {
            const { apiKey, model, temperature } = RED.settings.openai;
            if (apiKey) config.apiKey = apiKey;
            if (model) config.model = model;
            if (temperature !== undefined) config.temperature = temperature;
        }
    }

    function getSystemPrompt(availableNodeTypes, nodesInWorkspace) {
        return {
            role: "system",
            content: `You are a Node-RED assistant with three primary functions:

1. ANSWER QUESTIONS
   When providing general information, use normal_reply function.
   - Provide Node-RED knowledge, concepts, and functionality explanations
   - Share best practices and optimization tips
   - Help troubleshoot common issues

2. CREATE NEW FLOWS
   When creating a new flow, use create_flow function with valid JSON.
   - Generate complete, importable Node-RED flow JSON from user descriptions
   - Include only necessary nodes from the available node types
   - Ensure all nodes have unique names and IDs
   - Changes that depend on other changes must be added after the changes they depend on. For example, if you want to add a debug node to see the output of an existing function node:
     1. First add the change to create the debug node
     2. Then add the change to update the function node's wires to connect to the new debug node

3. UPDATE EXISTING FLOWS
   When modifying existing flows, use update_flow function with valid JSON.
   - Preserve all existing node IDs
   - Generate the operations one by one as shown in the function definitions.
   - Ensure wires are correctly specified for all nodes
   - Preserve the position of the nodes if it wasn't explicitly changed.

WORKSPACE CONTEXT:
${nodesInWorkspace ? `Currently visible nodes: ${JSON.stringify(nodesInWorkspace)}` : 'No nodes currently in workspace'}

AVAILABLE NODE TYPES:
${JSON.stringify(availableNodeTypes)}

CRITICAL REQUIREMENTS:
- When generating code inside a node, make sure not to comment the code if you put it on the same line as a comment.
- Only use node types from the available list above
- Do not create custom nodes when standard nodes will work
- Generate valid, properly formatted JSON
- Wire connections must be flat arrays of strings
- For new flows: generate unique IDs for all nodes
- For updates: preserve all existing node IDs
- Always verify wire connections are correctly specified

RESPONSE FORMAT:
- For general questions: normal_reply
- For new flows: create_flow
- For flow updates: update_flow`
        };
    }

    function prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const recentHistory = conversationHistory.slice(-1000);
        return [...recentHistory, {
            role: "user",
            content: userMessage
        }];
    }

    function getFunctionDefinitions() {
        return [
            {
                name: "normal_reply",
                description: "Used for standard conversation when the user is not requesting a flow to be created",
                input_schema: {
                    type: "object",
                    properties: {
                        response: {
                            type: "string",
                            description: "The assistant's response to the user's query"
                        }
                    },
                    required: ["response"]
                }
            },
            {
                name: "create_flow",
                description: "Creates a Node-RED flow based on the user description",
                input_schema: {
                    type: "object",
                    properties: {
                        flow: {
                            type: "string",
                            description: "The stringified JSON representation of the Node-RED flow that can be imported directly. Must be a valid JSON string."
                        },
                        explanation: {
                            type: "string",
                            description: "A detailed explanation of the flow, how it works, and any special considerations. Always include the explanation in the response !!"
                        }
                    },
                    required: ["flow", "explanation"]
                }
            },
            {
                name: "update_flow",
                description: "Updates an existing flow using git-like change operations",
                input_schema: {
                    type: "object",
                    properties: {
                        changes: {
                            type: "array",
                            description: "List of git-like operations to apply to the flow",
                            items: {
                                type: "object",
                                properties: {
                                    operation: {
                                        type: "string",
                                        enum: ["add", "modify", "remove"],
                                        description: "Type of change operation"
                                    },
                                    nodeId: {
                                        type: "string",
                                        description: "ID of the node being modified"
                                    },
                                    value: {
                                        type: "string",
                                        description: "Entire Stringified JSON of the node to be added or modified"
                                    },
                                    description: {
                                        type: "string",
                                        description: "Description of the change"
                                    }
                                },
                                required: ["operation", "nodeId", "value", "description"]
                            }
                        },
                        explanation: {
                            type: "string",
                            description: "Overall explanation of the changes shown to the user"
                        }
                    },
                    required: ["changes", "explanation"]
                }
            }
        ];
    }

    function appendImportantInstructions(message) {
        let updatedMessage = message + "\n\nIMPORTANT: If you are updating a flow, you must include the entire flow json in the flow property. Do not generate partial updates. If a flow is not being changed, include it in the update flow. We will take the entir flow json and import it.";
        updatedMessage = updatedMessage + "\n\nIMPORTANT: Beautify always the workflow based on the position and subflows";
        return updatedMessage;
    }

    function prepareApiRequestBody(messages, availableNodeTypes, nodesInWorkspace) {
        return {
            model: config.model,
            messages: messages,
            temperature: config.temperature,
            tools: getFunctionDefinitions(),
            max_tokens: 4000,
            system: getSystemPrompt(availableNodeTypes, nodesInWorkspace).content
        };
    }

    async function callOpenAIAPI(messages, availableNodeTypes, nodesInWorkspace) {
        if (!config.apiKey) {
            throw new Error("OpenAI API key not configured. Please set it in the settings.");
        }

        // Update the last message with important instructions
        const updatedMessages = [...messages];
        const lastIndex = updatedMessages.length - 1;
        updatedMessages[lastIndex] = {
            ...updatedMessages[lastIndex],
            content: appendImportantInstructions(updatedMessages[lastIndex].content)
        };

        const requestBody = prepareApiRequestBody(updatedMessages, availableNodeTypes, nodesInWorkspace);
        
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': config.apiKey,
                'anthropic-dangerous-direct-browser-access': true,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(requestBody)
        });

        const responseData = await response.json();
        console.log(responseData, "response");
        
        if (!response.ok) {
            throw new Error(`OpenAI API Error: ${responseData.error?.message || 'Unknown error'}`);
        }

        return responseData;
    }

    function handleNormalReply(functionArgs, nodesInWorkspace) {
        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: functionArgs.response
        };
    }

    function handleCreateFlow(functionArgs, nodesInWorkspace) {
        try {
            const flowJson = JSON.parse(functionArgs.flow);
            return {
                success: true,
                isFlow: true,
                flow: flowJson,
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error parsing flow JSON:", e);
            return {
                success: false,
                isFlow: false,
                content: "I tried to create a flow but encountered an error in the JSON format. Please try again with a simpler description.",
                error: e.message
            };
        }
    }

    function parseChanges(changes) {
        // Convert string input to object if needed
        const changesArray = Array.isArray(changes) ? changes : JSON.parse(JSON.stringify(changes));
        
        // Parse any string values into objects
        changesArray.forEach(change => {
            if (typeof change.value === 'string') {
                change.value = JSON.parse(JSON.stringify(change.value));
            }
        });

        return changesArray;
    }

    function handleUpdateFlow(functionArgs, nodesInWorkspace) {
        console.log(functionArgs.changes, "changes");
        try {
            // Ensure changes are properly sanitized before processing
            const sanitizedChanges = parseChanges(functionArgs.changes);
            
            const flow = applyFlowChanges(nodesInWorkspace, sanitizedChanges);
            console.log(flow, "flow");
            
            return {
                success: true,
                isFlow: false,
                isUpdate: true,
                flow: flow,
                changes: sanitizedChanges.map(change => ({
                    ...change,
                    timestamp: Date.now(),
                    status: 'pending'
                })),
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error in handleUpdateFlow:", e);
            return {
                success: false,
                isFlow: false,
                isUpdate: true,
                content: "Error processing flow updates: " + e.message
            };
        }
    }

    function applyAddOperation(flow, nodeValue) {
        flow.push(nodeValue);
        return flow;
    }

    function applyModifyOperation(flow, nodeId, nodeValue) {
        const nodeIndex = flow.findIndex(node => node.id === nodeId);
        if (nodeIndex !== -1) {
            flow[nodeIndex] = { ...flow[nodeIndex], ...nodeValue };
        } else {
            console.log("Couldn't find node", nodeId);
        }
        return flow;
    }

    function applyRemoveOperation(flow, nodeId) {
        const deleteIndex = flow.findIndex(node => node.id === nodeId);
        if (deleteIndex !== -1) {
            flow.splice(deleteIndex, 1);
        } else {
            console.log("Couldn't find node", nodeId);
        }
        return flow;
    }

    function applyFlowChanges(currentFlow, changes) {
        const newFlow = [...currentFlow]; // Create a copy to avoid modifying the original

        changes.forEach(change => {
            const { operation, nodeId } = change;
            console.log(operation, "operation");
            let nodeValue;
            
            try {
                if (change.value && change.value !== "") {
                    nodeValue = JSON.parse(change.value);
                } else {
                    nodeValue = "";
                }
            } catch (e) {
                console.error(`Error parsing value for node ${nodeId}:`, e);
                return; // Skip this change if parsing fails
            }

            switch (operation) {
                case 'add':
                    applyAddOperation(newFlow, nodeValue);
                    break;
                    
                case 'modify':
                    applyModifyOperation(newFlow, nodeId, nodeValue);
                    break;
                    
                case 'remove':
                    applyRemoveOperation(newFlow, nodeId);
                    break;
            }
        });

        return newFlow;
    }

    function getHandlerForToolName(name) {
        const handlers = {
            normal_reply: handleNormalReply,
            create_flow: handleCreateFlow,
            update_flow: handleUpdateFlow
        };
        
        return handlers[name] || 
               (() => handleNormalReply({ response: "I couldn't process your request properly." }));
    }

    function processToolUse(toolUse, nodesInWorkspace) {
        const { name, input } = toolUse;
        const handler = getHandlerForToolName(name);
        return handler(input, nodesInWorkspace);
    }

    async function processMessage(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const messages = prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace);
        const data = await callOpenAIAPI(messages, availableNodeTypes, nodesInWorkspace);
        
        if (data.content && Array.isArray(data.content)) {
            for (const item of data.content) {
                if (item.type === 'tool_use') {
                    return processToolUse(item, nodesInWorkspace);
                }
            }
        }

        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: data.content[0].text
        };
    }

    // Legacy support
    async function createFlow(userMessage, conversationHistory, availableNodeTypes) {
        return processMessage(userMessage, conversationHistory, availableNodeTypes);
    }

    function init() {
        loadConfig();
    }

    return {
        init,
        createFlow,
        processMessage,
        loadConfig,
        applyFlowChanges
    };
})(); 