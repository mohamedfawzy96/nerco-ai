// TODO: Call it anthropic service
RED.openAIService = (function() {
    // Configuration object
    const config = {
        apiKey: "",
        model: "claude-3-5-sonnet-20240620",
        temperature: 0.0
    };

    // Function to load configuration from Node-RED settings
    function loadConfig() {
        // First try to load from localStorage
        const savedApiKey = localStorage.getItem('node-red-openai-api-key');
        if (savedApiKey && savedApiKey.trim().length > 0) {
            config.apiKey = savedApiKey;
        }
        
        // Then check Node-RED settings (will override localStorage if present)
        if (RED.settings?.openai) {
            const { apiKey, model, temperature } = RED.settings.openai;
            if (apiKey) config.apiKey = apiKey;
            if (model) config.model = model;
            if (temperature !== undefined) config.temperature = temperature;
        }
    }
    
    // Function to update API key
    function updateApiKey(apiKey) {
        if (apiKey && apiKey.trim().length > 0) {
            config.apiKey = apiKey;
            return true;
        }
        return false;
    }

    function getSystemPrompt(availableNodeTypes, nodesInWorkspace) {
        return {
            role: "system",
            content: `You are a Node-RED assistant with three primary functions:

1. ANSWER QUESTIONS
   When providing general information, use normal_reply function.
   - Provide Node-RED knowledge, concepts, and functionality explanations
   - Share best practices and optimization tips
   - Help troubleshoot common issues

2. CREATE NEW FLOWS
   When creating a new flow, use create_flow function with valid JSON.
   - Generate complete, importable Node-RED flow JSON from user descriptions
   - Include only necessary nodes from the available node types
   - Ensure all nodes have unique names and IDs
   - Changes that depend on other changes must be added after the changes they depend on. For example, if you want to add a debug node to see the output of an existing function node:
     1. First add the change to create the debug node
     2. Then add the change to update the function node's wires to connect to the new debug node

3. UPDATE EXISTING FLOWS
   When modifying existing flows, use update_flow function with valid JSON.
   - Preserve all existing node IDs
   - Generate a list of changes one by one as shown in the function definitions.
   - Ensure wires are correctly specified for all nodes
   - Preserve the position of the nodes if it wasn't explicitly changed.

WORKSPACE CONTEXT:
${nodesInWorkspace ? `Currently visible nodes: ${JSON.stringify(nodesInWorkspace)}` : 'No nodes currently in workspace'}

AVAILABLE NODE TYPES:
${JSON.stringify(availableNodeTypes)}

CRITICAL REQUIREMENTS:
- Only use node types from the available list above
- Do not create custom nodes when standard nodes will work
- Generate valid, properly formatted JSON
- Wire connections must be flat arrays of strings
- For new flows: generate unique IDs for all nodes
- For updates: preserve all existing node IDs
- Always verify wire connections are correctly specified`
        };
    }

    function prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const recentHistory = conversationHistory.slice(-1000);
        return [...recentHistory, {
            role: "user",
            content: userMessage
        }];
    }

    function getFunctionDefinitions() {
        return [
            {
                name: "normal_reply",
                description: "Used for standard conversation when the user is not requesting a flow to be created",
                input_schema: {
                    type: "object",
                    properties: {
                        response: {
                            type: "string",
                            description: "The assistant's response to the user's query"
                        }
                    },
                    required: ["response"]
                }
            },
            {
                name: "create_flow",
                description: "Creates a Node-RED flow based on the user description",
                input_schema: {
                    type: "object",
                    properties: {
                        flow: {
                            type: "string",
                            description: "The stringified JSON representation of the Node-RED flow that can be imported directly. Must be a valid JSON string."
                        },
                        explanation: {
                            type: "string",
                            description: "A detailed explanation of the flow, how it works, and any special considerations"
                        }
                    },
                    required: ["flow", "explanation"]
                }
            },
            {
                name: "update_flow",
                description: "Updates an existing flow using git-like change operations",
                input_schema: {
                    type: "object",
                    properties: {
                        changes: {
                            type: "array",
                            description: "List of git-like operations to apply to the flow",
                            items: {
                                type: "object",
                                properties: {
                                    operation: {
                                        type: "string",
                                        enum: ["add", "modify", "remove"],
                                        description: "Type of change operation"
                                    },
                                    nodeId: {
                                        type: "string",
                                        description: "ID of the node being modified"
                                    },
                                    value: {
                                        type: "string",
                                        description: "Entire Stringified JSON of the node to be added or modified"
                                    },
                                    description: {
                                        type: "string",
                                        description: "Description of the change"
                                    }
                                },
                                required: ["operation", "nodeId", "value", "description"]
                            }
                        },
                        explanation: {
                            type: "string",
                            description: "Overall explanation of the changes shown to the user"
                        }
                    },
                    required: ["changes", "explanation"]
                }
            }
        ];
    }

    async function callOpenAIAPI(messages, availableNodeTypes, nodesInWorkspace) {
        if (!config.apiKey) {
            throw new Error("Anthropic API key not configured. Please set it in the settings.");
        }

        last_message = messages[messages.length - 1];
        last_message = last_message + "\n\nIMPORTANT: Beautify always the workflow based on the position and subflows";
        last_message = last_message + "\n\nIMPORTANT: If a node red plugin is needed, ask the user to install it first before creating the flow. If the user already has it installed, just use it.";
        last_message = last_message + "\n\nIMPORTANT: Always make sure changes in the update flow is a list of changes not a string.";

        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': config.apiKey,
                'anthropic-dangerous-direct-browser-access': true,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
                model: config.model,
                messages: messages,
                temperature: config.temperature,
                tools: getFunctionDefinitions(),
                max_tokens: 4000,
                system: getSystemPrompt(availableNodeTypes, nodesInWorkspace).content
            })
        });

        const responseData = await response.json();
        console.log(responseData, "response");
        if (!response.ok) {
            throw new Error(`Anthropic API Error: ${responseData.error?.message || 'Unknown error'}`);
        }

        return responseData;
    }

    // Add a new utility function for safe JSON parsing with sanitization
    function safeParseJSON(jsonString) {
        if (!jsonString || typeof jsonString !== 'string') {
            return null;
        }

        try {
            // First try straight parsing
            return JSON.parse(jsonString);
        } catch (e) {
            // If parsing fails, try to sanitize the string
            try {
                // Sanitize the string by removing control characters and fixing escapes
                const sanitizedString = jsonString
                    .replace(/[\u0000-\u0009\u000B-\u000C\u000E-\u001F\u007F-\u009F]/g, "") // Remove control chars but keep \n \r \t
                    .replace(/\\(?!["\\/bfnrt])/g, "\\\\"); // Escape backslashes properly
                
                // Try parsing again
                return JSON.parse(sanitizedString);
            } catch (err) {
                // If it still fails, throw the original error
                console.error("Failed to parse JSON after sanitization:", err);
                throw e;
            }
        }
    }

    function handleNormalReply(functionArgs, nodesInWorkspace) {
        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: functionArgs.response
        };
    }

    function handleCreateFlow(functionArgs, nodesInWorkspace) {
        try {
            const flowJson = safeParseJSON(functionArgs.flow);
            if (!flowJson) {
                throw new Error("Invalid flow JSON");
            }
            return {
                success: true,
                isFlow: true,
                flow: flowJson,
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error parsing flow JSON:", e);
            return {
                success: false,
                isFlow: false,
                content: "I tried to create a flow but encountered an error in the JSON format. Please try again with a simpler description.",
                error: e.message
            };
        }
    }

    function handleUpdateFlow(functionArgs, nodesInWorkspace) {
        console.log(functionArgs.changes, "changes");

        if (!Array.isArray(functionArgs.changes)) {
            functionArgs.changes = safeParseJSON(functionArgs.changes);
        }

        try {
            // Ensure changes are properly sanitized before processing
            const sanitizedChanges = functionArgs.changes.map(change => {
                // Clone the change object to avoid modifying the original
                const sanitizedChange = {...change};
                
                // If value exists and is a string, ensure it's valid JSON
                if (sanitizedChange.value && typeof sanitizedChange.value === 'string') {
                    // We don't actually modify the value here anymore, just verify it can be parsed
                    safeParseJSON(sanitizedChange.value);
                }
                return sanitizedChange;
            });
            
            flow = applyFlowChanges(nodesInWorkspace, sanitizedChanges);
            console.log(flow, "flow");
            return {
                success: true,
                isFlow: false,
                isUpdate: true,
                flow: flow,
                changes: sanitizedChanges.map(change => ({
                    ...change,
                    timestamp: Date.now(),
                    status: 'pending'
                })),
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error in handleUpdateFlow:", e);
            return {
                success: false,
                isFlow: false,
                isUpdate: true,
                content: "Error processing flow updates: " + e.message
            };
        }
    }

    // Add new utility function to apply changes
    function applyFlowChanges(currentFlow, changes) {
        const newFlow = currentFlow;

        changes.forEach(change => {
            const { operation, nodeId } = change;
            let nodeValue;
            
            try {
                if (change.value && change.value !== "") {
                    nodeValue = safeParseJSON(change.value);
                } else {
                    nodeValue = "";
                }
            } catch (e) {
                console.error(`Error parsing value for node ${nodeId}:`, e);
                return; // Skip this change if parsing fails
            }

            switch (operation) {
                case 'add':
                    // Add new node to the flow
                    newFlow.push(nodeValue);
                    break;
                    
                case 'modify':
                    // Find and update existing node
                    const nodeIndex = newFlow.findIndex(node => node.id === nodeId);
                    if (nodeIndex !== -1) {
                        newFlow[nodeIndex] = { ...newFlow[nodeIndex], ...nodeValue };
                    } else {
                        console.log("Couldn't find node", nodeId);
                    }
                    break;
                    
                case 'remove':
                    // Remove node from flow
                    const deleteIndex = newFlow.findIndex(node => node.id === nodeId);
                    if (deleteIndex !== -1) {
                        newFlow.splice(deleteIndex, 1);
                    } else {
                        console.log("Couldn't find node", nodeId);
                    }
                    break;
            }
        });

        return newFlow;
    }

    async function processMessage(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const messages = prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace);
        const data = await callOpenAIAPI(messages, availableNodeTypes, nodesInWorkspace);
        
        if (data.content && Array.isArray(data.content)) {
            for (const item of data.content) {
                if (item.type === 'tool_use') {
                    const { name, input } = item;
                    const functionArgs = input;

                    const handlers = {
                        normal_reply: handleNormalReply,
                        create_flow: handleCreateFlow,
                        update_flow: handleUpdateFlow
                    };

                    return handlers[name]?.(functionArgs, nodesInWorkspace) || 
                           handleNormalReply({ response: "I couldn't process your request properly." }, nodesInWorkspace);
                } 
            }
        }

        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: data.content[0].text
        };
    }

    // Legacy support
    async function createFlow(userMessage, conversationHistory, availableNodeTypes) {
        return processMessage(userMessage, conversationHistory, availableNodeTypes);
    }

    function init() {
        loadConfig();
    }

    return {
        init,
        createFlow,
        processMessage,
        loadConfig,
        applyFlowChanges,
        updateApiKey
    };
})(); 
